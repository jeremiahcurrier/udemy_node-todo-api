//////////////////////////////////////////////////////////////////
S: 7; P: 85; 'Testing PATCH /todos/:id'
//////////////////////////////////////////////////////////////////

new describe block in server.test.js

  describe('PATCH /todos/:id', () => {
    // 2 test cases
    // take our 1st todo and set text to something else and completed from false to true
    it('should update the todo', (done) => {
      // grab id of first item
      var hexId = todos[0]._id.toHexString();
      var text = 'This should be the new text';
        // make request to express application
        request(app)
          .patch(`/todos/${hexId}`) // url with template string
          .send({
            // send data before making assertions
            completed: true,
            // text: text
            text // es6
          })
          .expect(200) // assert 200
          .expect((res) => {
            expect(res.body.todo.text).toBe(text);
            expect(res.body.todo.completed).toBe(true);
            expect(typeof res.body.todo.completedAt).toBe('number');
          })
          // BEFORE CUSTOM ASSERTION - call end
          .end(done);
    });

    // toggling that completed value for the second todo
    it('should clear completedAt when todo is not completed', (done) => {
      // grab id of second item
      var hexId = todos[1]._id.toHexString();
      var text = 'patched up real nice';
      // make request to express application
      request(app)
        .patch(`/todos/${hexId}`)
        // send the data before you can make the assertion about its response
        .send({
          text,
          completed: false
        })
        // expect http 200 ok
        .expect(200)
        // custom assertion text changed, completed false, completedAt is null via .toNotExist
        .expect((res) => {
          // custom assertions here
          expect(res.body.todo.text).toBe(text);
          expect(res.body.todo.completed).toBe(false);
          expect(res.body.todo.completedAt).toBeFalsy();
        })
        .end(done);
    });
  });









server.js

logic for PATCH

    app.patch('/todos/:id', (req, res) => {
    	var id = req.params.id;
    	var body = _.pick(req.body, ['text', 'completed']); // has subset of things user passed to us and we only want to PICK some things for the user to be able to update.

    	if (!ObjectID.isValid(id)) {
    		return res.status(404).send();
    	}

    	// checking completed value and setting completedAt (timestamp or cleared)
    	if(_.isBoolean(body.completed) && body.completed) {
    		body.completedAt = new Date().getTime(); // num ms on midnight of jan 1st since 1970 epoch-epic
    	} else {
    		// not boolean and or not true
    		body.completed = false;
    		body.completedAt = null; // remove form db = null
    	}

    	// query to update db
    	Todo.findByIdAndUpdate(id, {$set: body}, {new: true}).then((todo) => { // use mongoDb operators (like incrementors or $set)
    		if (!todo) {
    			return res.status(404).send();
    		}

    		// res.send({todo: todo});
    		res.send({todo}); // es6 syntax
    		// success
    	}).catch((e) => {
    		res.status(400).send();
    	});
    });

    app.listen(port, () => {
    	console.log(`Started on port ${port}`);
    });

    module.exports = {app};






//////////////////////////////////////////////////////////////////
S: 7; P: 86; 'Creating a test database'
//////////////////////////////////////////////////////////////////


process.env.NODE_ENV === 'production' // default (app on Heroku)
process.env.NODE_ENV === 'development' // run app locally
process.env.NODE_ENV === 'test' // run app through mocha

server/config/config.js

  var env = process.env.NODE_ENV || 'development';

  if (env === 'development') {
  	// setup mongoDB url
  	process.env.PORT === 3000;
  	process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoApp';
  } else if (env === 'test') {
  	// also wanna setup custom DB url
  	process.env.PORT === 3000;
  	process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoAppTest';
  }


package.json

  {
    "name": "todo-api",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "start": "node server/server.js",
      "test": "export NODE_ENV=test || \"SET NODE_ENV=test\" && mocha server/**/*.test.js",
      "test-watch": "nodemon --exec 'npm test'"
    },
    "engines": {
      "node": "10.9.0"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jeremiahcurrier/udemy_node-todo-api.git"
    },
    "author": "",
    "license": "ISC",
    "bugs": {
      "url": "https://github.com/jeremiahcurrier/udemy_node-todo-api/issues"
    },
    "homepage": "https://github.com/jeremiahcurrier/udemy_node-todo-api#readme",
    "dependencies": {
      "body-parser": "^1.18.3",
      "express": "^4.16.4",
      "lodash": "^4.17.11",
      "mongodb": "^3.1.10",
      "mongoose": "^4.5.9"
    },
    "devDependencies": {
      "expect": "^23.6.0",
      "mocha": "^5.2.0",
      "nodemon": "^1.18.9",
      "supertest": "^3.3.0"
    }
  }




  //////////////////////////////////////////////////////////////////
  Security and Authentication
  S: 8; P: 88; 'Setting up the User Model'
  //////////////////////////////////////////////////////////////////

  server/models/user.js

    const mongoose = require('mongoose');
    const validator = require('validator');

    // how could a database get compromised?

    var User = mongoose.model('User', {
    	email: {
    		type: String,
    		required: true,
    		trim: true,
    		minLength: 1,
    		unique: true, // prevents another user in db from same email
    		validate: {
    			// validator: (value) => {
    			// 	// call function
    			// 	return validator.isEmail(value);
    			// },
    			validator: validator.isEmail,
    			message: '{VALUE} is not a valid email'
    		}
    	},
    	password: {
    		type: String,
    		require: true,
    		minLength: 6
    	},
    // nested document available in mongo NOT in postgres - tokens is array - feature in mongo only
    	tokens: [{
    		access: {
    			// code
    			type: String,
    			required: true
    		},
    		token: {
    			// code
    			type: String,
    			require: true
    		}
    	}]

    });

    // export the User model
    module.exports = {User};


  server/server.js

  ...
    // POST to /users same for creating new todos
    app.post('/users', (req, res) => {
    	var body = _.pick(req.body, ['email', 'password']);
    	var user = new User(body);

    	user.save().then((user) => {
    		res.send(user);
    	}, (e) => {
    		res.status(400).send(e);
    	});
    });
















  //////////////////////////////////////////////////////////////////
  S: 8; P: 89; 'JWTs and Hashing'
  //////////////////////////////////////////////////////////////////

  encryption & hashing algorithms i.e. AES, MD5, SHA 256

  hashing = 1 way algorithm meaning given this 'message' you will always get the same result BUT YOU CAN NOT GET THE ORIGINAL MESSAGE BACK with just the result

  so with the hash you have no idea what the message is...

  HOW IS HASHING USED? passwords stored in the database

  hashing is a way to obfuscate a plain text password
  someone in the middle could still see the value.... https prevents the MITM attack
  BUT prevents someone on client from manipulating value and changing it to something else

  EXAMPLE: Let's say app sends token for user 3, user 3 changes token to user 4 and tries to delete someone elses data ... we can ensure value, the user id, does not change, spot change, deny user access because they probably created token on their own....


  playground/hashing.js



  // grab prop off require return result
  const {SHA256} = require('crypto-js');
  const jwt = require('jsonwebtoken');


  // https://jwt.io/

  // create token
  // verify it

  var data = {
    id: 10
  };
  var token = jwt.sign(data, '123abc');
  console.log(token);
  // jwt.sign // takes obj (data w user id), signs it, returns token value
  // jwt.verify // takes token + secret to ensure data not manipulated (shared secret)
  // var decoded = jwt.verify(token + '1', '123abc');
  // var decoded = jwt.verify(token, '123abcc');
  var decoded = jwt.verify(token, '123abc');
  console.log('decoded', decoded);





  // var message = 'I am user number 3';
  // var hash = SHA256(message).toString();
  //
  // console.log(`Message: ${message}`);
  // console.log(`Hash: ${hash}`);

  // // JWT concept
  // var data = {
  //   id: 4
  // };
  // // var token = {
  // //   data,
  // //   hash: SHA256(JSON.stringify(data)).toString()
  // // }
  // // token not foolproof... let's say user changes the data.id property to 5 all they have to do is re-hash that data > add it on to the 'hash' property > send the 'token' back and they technically could trick us... HOW TO PREVENT THIS?
  // // 'salt the hash' === add something onto the hash that's unique that changes the value
  // // password + somesecret
  //
  // var token = {
  //   data,
  //   hash: SHA256(JSON.stringify(data) + 'somesecret').toString() // somesecret is only on the server...
  // }
  //
  // // mocks up a hash manipulation
  // // token.data.id = 5;
  // // token.hash = SHA256(JSON.stringify(token.data)).toString();
  //
  // var resultHash = SHA256(JSON.stringify(token.data) + 'somesecret').toString();
  //
  // if (resultHash === token.hash) {
  //   // data not manipulated bc of the salt
  //   console.log('Data was not changed');
  // } else {
  //   // data was changed, do not trust, likely incorrect/malicious
  //   console.log(('Data was changed. Do not trust.'));
  // }



























//////////////////////////////////////////////////////////////////
S: 8; P: 90; 'Generating Auth Tokens and Setting Headers'
//////////////////////////////////////////////////////////////////

  2 methods to explore in this video
  model methods = upper-case User object (.findByToken is custom model method)
  instance methods = called on individual user (requires individual user document)

  User = model method
  user = instance method


  User.findByToken



  server/models/user.js

    const mongoose = require('mongoose');
    const validator = require('validator');
    const jwt = require('jsonwebtoken');
    const _ = require('lodash');

    var UserSchema = new mongoose.Schema({
    	email: {
    		type: String,
    		required: true,
    		trim: true,
    		minLength: 1,
    		unique: true,
    		validate: {
    			validator: validator.isEmail,
    			message: '{VALUE} is not a valid email'
    		}
    	},
    	password: {
    		type: String,
    		require: true,
    		minLength: 6
    	},
    	tokens: [{
    		access: {
    			type: String,
    			required: true
    		},
    		token: {
    			type: String,
    			require: true
    		}
    	}]
    });

    UserSchema.methods.toJSON = function() {
    	var user = this;
    	var userObject = user.toObject();

    	return _.pick(userObject, ['_id', 'email']);
    };

    // arrow functions do not bind a 'this' keyword which we need in this case, why? because 'this' stores the individual document
    UserSchema.methods.generateAuthToken = function () {
    	var user = this;
    	var access = 'auth';
    	var token = jwt.sign({_id: user._id.toHexString(), access}, 'secretvalue').toString();

    	// user.tokens.push({access, token});
    	user.tokens = user.tokens.concat([{access, token}]); // works in wider range of mongodb versions

    	// // need to save
    	// user.save().then(() => {
    	// 	// success
    	// 	return token;
    	// }).then((token) => {
    	// 	// this happens in server.js
    	// })

    	// in order to allow server.js to chain onto the promise we'll return interval
    	return user.save().then(() => {
    		return token;
    	});
    };

    var User = mongoose.model('User', UserSchema);

    module.exports = {User};




  playground/hashing.js

    // grab prop off require return result
    const {SHA256} = require('crypto-js');
    const jwt = require('jsonwebtoken');


    // https://jwt.io/

    // create token
    // verify it

    var data = {
      id: 10
    };
    var token = jwt.sign(data, '123abc');
    console.log(token);
    // jwt.sign // takes obj (data w user id), signs it, returns token value
    // jwt.verify // takes token + secret to ensure data not manipulated (shared secret)
    // var decoded = jwt.verify(token + '1', '123abc');
    // var decoded = jwt.verify(token, '123abcc');
    var decoded = jwt.verify(token, '123abc');
    console.log('decoded', decoded);





    // var message = 'I am user number 3';
    // var hash = SHA256(message).toString();
    //
    // console.log(`Message: ${message}`);
    // console.log(`Hash: ${hash}`);

    // // JWT concept
    // var data = {
    //   id: 4
    // };
    // // var token = {
    // //   data,
    // //   hash: SHA256(JSON.stringify(data)).toString()
    // // }
    // // token not foolproof... let's say user changes the data.id property to 5 all they have to do is re-hash that data > add it on to the 'hash' property > send the 'token' back and they technically could trick us... HOW TO PREVENT THIS?
    // // 'salt the hash' === add something onto the hash that's unique that changes the value
    // // password + somesecret
    //
    // var token = {
    //   data,
    //   hash: SHA256(JSON.stringify(data) + 'somesecret').toString() // somesecret is only on the server...
    // }
    //
    // // mocks up a hash manipulation
    // // token.data.id = 5;
    // // token.hash = SHA256(JSON.stringify(token.data)).toString();
    //
    // var resultHash = SHA256(JSON.stringify(token.data) + 'somesecret').toString();
    //
    // if (resultHash === token.hash) {
    //   // data not manipulated bc of the salt
    //   console.log('Data was not changed');
    // } else {
    //   // data was changed, do not trust, likely incorrect/malicious
    //   console.log(('Data was changed. Do not trust.'));
    // }









































//////////////////////////////////////////////////////////////////
S: 8; P: 91; 'Private routes and auth middleware'
//////////////////////////////////////////////////////////////////

add express middleware making it easy to make a route private






server/server.js


  require('./config/config');

  const _ = require('lodash');
  const express = require('express');
  const bodyParser = require('body-parser');
  const {ObjectID} = require('mongodb');

  var {mongoose} = require('./db/mongoose');
  var {Todo} = require('./models/todo');
  var {User} = require('./models/user');
  var {authenticate} = require('./middleware/authenticate');

  var app = express();
  // port set on Heroku for prod, locally for dev, and final env = test
  const port = process.env.PORT || 3000;

  app.use(bodyParser.json());

  app.post('/todos', (req, res) => {
  	var todo = new Todo({
  		text: req.body.text
  	});

  	todo.save().then((doc) => {
  		res.send(doc);
  	}, (e) => {
  		res.status(400).send(e);
  	});
  });

  app.get('/todos', (req, res) => {
  	Todo.find().then((todos) => {
  		res.send({todos});
  	}, (e) => {
  		res.status(400).send(e);
  	});
  });

  app.get('/todos/:id', (req, res) => {
  	var id = req.params.id;

  	if (!ObjectID.isValid(id)) {
  		return res.status(404).send();
  	}

  	Todo.findById(id).then((todo) => {
  	  if (!todo) {
  			return res.status(404).send();
  	  }

  		// res.send(todo);
  		// res.send({todo: todo});
  		res.send({todo}); // es6 syntax
  	}).catch((e) => {
  		res.status(400).send();
  	});
  });

  app.delete('/todos/:id', (req, res) => {
  	// get the id
  	var id = req.params.id;
  	// validate the id -> not valid? return 404
  	if (!ObjectID.isValid(id)) {
  		return res.status(404).send();
  	}
  	// remove todo by id
  	Todo.findByIdAndRemove(id).then((todo) => {
  	  // console.log(todo);
  		// success
  		if (!todo) {
  			// if no doc, send 404
  			return res.status(404).send();
  		}
  			// if doc, send doc back with 200
  			// res.send(todo);
  			// res.send({todo: todo});
  			res.send({todo}); // es6 syntax
  		// error
  	}).catch((e) => {
  		// 400 with empty body
  		res.status(400).send();
  	})
  });

  app.patch('/todos/:id', (req, res) => {
  	var id = req.params.id;
  	var body = _.pick(req.body, ['text', 'completed']); // has subset of things user passed to us and we only want to PICK some things for the user to be able to update.

  	if (!ObjectID.isValid(id)) {
  		return res.status(404).send();
  	}

  	// checking completed value and setting completedAt (timestamp or cleared)
  	if(_.isBoolean(body.completed) && body.completed) {
  		body.completedAt = new Date().getTime(); // num ms on midnight of jan 1st since 1970 epoch-epic
  	} else {
  		// not boolean and or not true
  		body.completed = false;
  		body.completedAt = null; // remove form db = null
  	}

  	// query to update db
  	Todo.findByIdAndUpdate(id, {$set: body}, {new: true}).then((todo) => { // use mongoDb operators (like incrementors or $set)
  		if (!todo) {
  			return res.status(404).send();
  		}

  		// res.send({todo: todo});
  		res.send({todo}); // es6 syntax
  		// success
  	}).catch((e) => {
  		res.status(400).send();
  	});
  });

  // POST to /users same for creating new todos
  app.post('/users', (req, res) => {
  	var body = _.pick(req.body, ['email', 'password']);
  	var user = new User(body);

  	user.save().then(() => {
  		return user.generateAuthToken(); // return since we're expecting a chaining promise
  	}).then((token) => {
  		// add token as http header and send token back
  		res.header('x-auth', token).send(user); // x- = custom header
  	}).catch((e) => {
  		res.status(400).send(e);
  	});
  });

  // // MIDDLEWARE function to use on all routes to make PRIVATE
  // var authenticate = (req, res, next) => {
  // 	var token = req.header('x-auth');
  //
  // 	User.findByToken(token).then((user) => {
  // 		if (!user) {
  // 			return Promise.reject(); // runs the error case in the catch below
  // 		}
  //
  // 		// res.send(user); //send back user
  // 		// modify request object to use inside a route
  // 		req.user = user;
  // 		req.token = token;
  // 		next();
  // 	}).catch((e) => {
  // 		res.status(401).send();
  // 	});
  // };

  // baby's first private route!
  app.get('/users/me', authenticate, (req, res) => {
  	res.send(req.user);
  });

  app.listen(port, () => {
  	console.log(`Started on port ${port}`);
  });

  module.exports = {app};









server/middleware/authenticate.js



  var {User} = require('./../models/user');

  // MIDDLEWARE function to use on all routes to make PRIVATE
  var authenticate = (req, res, next) => {
  	var token = req.header('x-auth');

  	User.findByToken(token).then((user) => {
  		if (!user) {
  			return Promise.reject(); // runs the error case in the catch below
  		}

  		// res.send(user); //send back user
  		// modify request object to use inside a route
  		req.user = user;
  		req.token = token;
      next();
  	}).catch((e) => {
  		res.status(401).send();
  	});
  };

  module.exports = {authenticate};





server/models/user.js

  const mongoose = require('mongoose');
  const validator = require('validator');
  const jwt = require('jsonwebtoken');
  const _ = require('lodash');

  var UserSchema = new mongoose.Schema({
  	email: {
  		type: String,
  		required: true,
  		trim: true,
  		minLength: 1,
  		unique: true,
  		validate: {
  			validator: validator.isEmail,
  			message: '{VALUE} is not a valid email'
  		}
  	},
  	password: {
  		type: String,
  		require: true,
  		minLength: 6
  	},
  	tokens: [{
  		access: {
  			type: String,
  			required: true
  		},
  		token: {
  			type: String,
  			require: true
  		}
  	}]
  });

  UserSchema.methods.toJSON = function() {
  	var user = this;
  	var userObject = user.toObject();

  	return _.pick(userObject, ['_id', 'email']);
  };

  // arrow functions do not bind a 'this' keyword which we need in this case, why? because 'this' stores the individual document
  UserSchema.methods.generateAuthToken = function () {
  	var user = this;
  	var access = 'auth';
  	var token = jwt.sign({_id: user._id.toHexString(), access}, 'secretvalue').toString();

  	// user.tokens.push({access, token});
  	user.tokens = user.tokens.concat([{access, token}]); // works in wider range of mongodb versions

  	// // need to save
  	// user.save().then(() => {
  	// 	// success
  	// 	return token;
  	// }).then((token) => {
  	// 	// this happens in server.js
  	// })

  	// in order to allow server.js to chain onto the promise we'll return interval
  	return user.save().then(() => {
  		return token;
  	});
  };

  // define a model methods
  // .statics = object; everything added to it becomes MODEL method (vs INSTANCE method)
  UserSchema.statics.findByToken = function (token) {
  	var User = this; // the Model is the 'this' binding
  	var decoded; // stores decoded JWT values - return from jwt.verify in hashing.js
  	// we wanna try something and catch the error if present
  	try {
  		// if error stop executing > move to catch block > continue in program
  		decoded = jwt.verify(token, 'secretvalue');
  	} catch (e) {
  		// return new Promise((resolve, reject) => {
  		// 	reject();
  		// });
  		return Promise.reject();
  	}

  	// success case - decode token passed in as header
  	// return to add to chaining
  	return User.findOne({
  		// query our nested object properties
  		'_id': decoded._id, // quotes not required unless a . in the key
  		// find user whose 'tokens' array has object where token prop = token prop passed in
  		'tokens.token': token,
  		'tokens.access': 'auth'
  	});
  };

  var User = mongoose.model('User', UserSchema);

  module.exports = {User};

















//////////////////////////////////////////////////////////////////
S: 8; P: 92; 'Hashing passwords'
//////////////////////////////////////////////////////////////////

How to hash a user's password before saving it to the database:

Hash it, salt it, store it in the database

BCRYPT (built in salting)


mongoose middleware lets you run certain code BEFORE or AFTER an PREVENT
i.e. run code before saving document (ensure hashedPassword is in place)

https://mongoosejs.com/docs/middleware.html


playground/hashing.js

  // grab prop off require return result
  const {SHA256} = require('crypto-js');
  const jwt = require('jsonwebtoken');
  const bcrypt = require('bcryptjs');

  var password = '123abc!';

  // // hash a password using bcrypt
  // bcrypt.genSalt(10, (err, salt) => {
  //   bcrypt.hash(password, salt, (err, hash) => {
  //     console.log(hash);
  //   });
  // });

  // how to compare if the hash = plain text password (when someone logs in)
  var hashedPassword = '$2a$10$NGZVeZ2kSczQOE6e/HlSSuuNIn1YfH5OJ3FQ0Pb9YNEvAT7U1ULh2';

  bcrypt.compare('password', hashedPassword, (err, res) => {
    // res is true or false
    console.log(res);
  });


server/models/user.js

...
  UserSchema.pre('save', function(next) { // save is Mongoose document save event
  	// do something
  	var user = this;
  	// now we can check if password was modified
  	if (user.isModified('password')) {
  		// hash the password using bcrypt if not modified
  		bcrypt.genSalt(10, (err, salt) => {
  			// user.password
  		  bcrypt.hash(user.password, salt, (err, hash) => {
  				// user.password = hash;
  				user.password = hash;
  				// next() to complete middleware and save document
  				next();
  		  });
  		});

  	} else {
  		next();
  	}
  });

  var User = mongoose.model('User', UserSchema);

  module.exports = {User};
































//////////////////////////////////////////////////////////////////
S: 8; P: 93; 'Seeding Test Database with Users'
//////////////////////////////////////////////////////////////////

created server/tests/seed folder with ~/seed.js file

  // imports
  // load in the objectId from the mongoDB native driver
  const {ObjectID} = require('mongodb'); // using es6 destructuring
  const jwt = require('jsonwebtoken');

  const {Todo} = require('./../../models/todo');
  const {User} = require('./../../models/user');

  const userOneId = new ObjectID();
  const userTwoId = new ObjectID();
  const users = [{
    _id: userOneId,
    email: 'andrew@example.com',
    password: 'userOnePass',
    tokens: [{
      access: 'auth',
      token: jwt.sign({_id: userOneId, access: 'auth'}, 'secretvalue').toString()
    }]
  }, {
    _id: userTwoId,
    email: 'jen@example.com',
    password: 'userTwoPass'
  }];

  // ADD SEED DATA
  // dummy todos
  const todos = [{
    _id: new ObjectID(),
    text: 'First test todo'
  }, {
    _id: new ObjectID(),
    text: 'Second test todo',
    completed: true,
    completedAt: 333
  }];

  const populateTodos = (done) => {
    // run before every test case
    // Todo.remove({}).then(() => done()); // wipe out our todos
    // insertMany (takes array and inserts into collection)
    Todo.remove({}).then(() => {
      return Todo.insertMany(todos); // this does not run our middleware
    }).then(() => done());
  };

  // we need to save the users AND ensure passwords are hashed
  const populateUsers = (done) => {
    User.remove({}).then(() => {
      // add records
      // var userOne = new User(users[0].save()); // returns a promise
      // var userTwo = new User(users[1].save()); // returns a promise
      // // we wanna wait for BOTH promises to finish
      // // Promise.all([userOne, userTwo]).then(() => {
      // //   // code
      // // });
      // return Promise.all([userOne, userTwo]);
      return User.insertMany(users);
    }).then(() => done());
  };

  // export
  module.exports = {todos, populateTodos, users, populateUsers};






Updated server.test.js file with this:

  // require supertest and expect - nodemon and mocha do not need to be required that is not how they are used
  const expect = require('expect');
  const request = require('supertest');
  // load in the objectId from the mongoDB native driver
  const {ObjectID} = require('mongodb');
  // local files
  const {app} = require('./../server');
  const {Todo} = require('./../models/todo');
  const {todos, populateTodos, users, populateUsers} = require('./seed/seed');



  // add TESTING LIFECYCLE METHOD
  beforeEach(populateUsers); // added before populateTodos
  beforeEach(populateTodos);

  ...





















//////////////////////////////////////////////////////////////////
S: 8; P: 94; 'Testing POST /users and GET /users/me'
//////////////////////////////////////////////////////////////////

new describe blocks in server.test.js

  describe('GET /users/me', () => {
    // valid auth token
    it('should return user if authenticated', (done) => {
      request(app)
        .get('/users/me')
        // SET a header
        .set('x-auth', users[0].tokens[0].token)
        // should get back a http 200
        .expect(200)
        // some things about the body
        .expect((res) => {
          // id in body should be id of user whose token we applied
          expect(res.body._id).toBe(users[0]._id.toHexString());
          expect(res.body.email).toBe(users[0].email);
        })
        // tack on a call to .end()
        .end(done);
    });
    // invalid auth token
    it('should return a 401 if not authenticated', (done) => {
      // users/me route, same GET, no x-auth token, expect a 401, body = {} since user not authed, call .end(done); toEqual
      request(app)
        .get('/users/me')
        .expect(401)
        // some things about the body
        .expect((res) => {
          expect(res.body).toEqual({});
        })
        .end(done);
    });
  });

  describe('POST /users', () => {
    // 3 cases
    it('should create a user', (done) => {
      var email = 'example@example.com';
      var password = '123mnb!';

      request(app)
        .post('/users')
        // send some data
        .send({email, password})
        // what should happen?
        // expect 200 status back
        .expect(200)
        // get x-auth token back
        .expect((res) => {
          // no errors expected
          expect(res.headers['x-auth']).toBeTruthy();
          expect(res.body._id).toBeTruthy();
          expect(res.body.email).toBe(email);
        })
        // now we can call end
        // .end(done);
        // but instead of passing in done pass in a custom function to query the database
        .end((err) => {
          if (err) {
            return done(err);
          }

          User.findOne({email}).then((user) => {
            // make some assertions about the document in the DB
            // toExist -> toBeTruthy
            expect(user).toBeTruthy();
            // toNotBe -> not.toBe
            expect(user.password).not.toBe(password); // if equal then passwords not getting hashed = problem
            done();
          });
        });
    });

    it('should return validation errors if request invalid', (done) => {
      request(app)
        .post('/users')
        // send invalid email and invalid password
        .send({
          email: 'foo',
          password: 'bar'
        })
      // expect 400
        .expect(400)
      // done
        .end(done);
    });

    it('should not create a user if email in use', (done) => {
      request(app)
        .post('/users')
      // email already taken (i.e. already in seed data)
        .send({
          email: users[0].email, // supposed to be VALID but already in use
          password: 'Password123!' // valid format for password
        })
      // expect 400
        .expect(400)
      // done
        .end(done);
    });
  });










//////////////////////////////////////////////////////////////////
S: 8; P: 95; 'Logging in - POST /users/login'
//////////////////////////////////////////////////////////////////

dedicated login route

currently only get an x-auth token via sign up call i.e. POST to /users

if you lose your token that's it!

you can't make another call to POST /users route because email will exist and will subsequently return an http 400

...

new route

server/server.js

  ...
  app.get('/users/me', authenticate, (req, res) => {
  	res.send(req.user);
  });

  // POST /users/login {email, password}
  // pick off these from request body res.send(body) data
  // make login call with email password and get that back
  app.post('/users/login', (req, res) => {
  	// YOU HAVE TO ALREADY EXIST BY EMAIL
  	var body = _.pick(req.body, ['email', 'password']);
  	// res.send(body);
  	User.findByCredentials(body.email, body.password).then((user) => {
  		// res.send(user);
  		// 'return' to keep the chain alive
  		return user.generateAuthToken().then((token) => {
  			res.header('x-auth', token).send(user);
  		});
  	}).catch((e) => {
  		// not able to login
  		res.status(400).send();
  	});
  });
  ...


new model method in user.js

server/models/user.js
  ...
    // define MODEL methods
    UserSchema.statics.findByCredentials = function (email, password) {
    	// find user that does have email of email passed in
    	var User = this;

    	return User.findOne({email}).then((user) => {
    		if (!user) {
    			// return a rejected promise
    			return Promise.reject();
    		}

    		// user does exist - no promise support in b-crypt...
    		// bcrypt.compare
    		return new Promise((resolve, reject) => {
    			// use bcrypt.compare to compare password in arg with user.password so in server.js we can do something with user when they come back
    			// User bcrypt.compare to compare password and user.password
    			bcrypt.compare(password, user.password, (err, res) => {
    				if (res) {
    					// if result = true you found user call resolve(user);
    					return resolve(user);
    				} else {
    					// if result = false - call reject to trigger catch case in server.js
    					return reject(); // no need to send anything back
    				}
    			});
    		})
    	})
    };
    ...













//////////////////////////////////////////////////////////////////
S: 8; P: 97; 'Logging out DELETE /users/me/token'
//////////////////////////////////////////////////////////////////

server/models/user.js

...

  UserSchema.methods.removeToken = function (token) {
  	// passing the token in to delete it
  	// call the update method to update our array
  	// we have an array of tokens defined in the UserScheme above - we want to remove any object from from the tokens array that has a 'token' property equal to the value we send in. We'll use a mongoDB 'operator' $pull to remove items from an array that match certain criteria.
  	var user = this; // lower case user because this is an instance method
  	return user.update({ // 'return' so we can chain this call
  		$pull: {
  			// set equal to an object
  			// define here what to pull from
  			// tokens: {
  			// 	token: token // will remove entire object / not just the token
  			// }
  			tokens: {token} // prop name === var name
  		}
  	});
  };

...


server/server.js

...

  // call to log out a user (requires auth) + remove token from tokens array
  // it is a DELETE route since we're trying to remove something
  // register it with a .delete()
  // make route private (auth required to run code) and remember in our authentication middleware we're storing the token to grab out later
  app.delete('/users/me/token', authenticate, (req, res) => {
  	// delete the token that was used inside the 'authentication' middleware
  	// to actually remove the token we will use a method - to define that method - an instance method - we have access to the user from the request so we'll call an instance method on the req.user
  	// ideally it returns a promise so we can respond to the user when the token is deleted
  	// define the removeToken() instance method inside of user.js
  	req.user.removeToken(req.token).then(() => {
  		// respond to user now that token is deleted
  		// 1st callback to then()
  		res.status(200).send();
  	}, () => {
  		// 2nd callback to then()
  		// if things do not go well for some reason
  		res.status(400).send();
  	})
  });

...




























//////////////////////////////////////////////////////////////////
S: 8; P: 98; 'Testing DELETE /users/me/token'
//////////////////////////////////////////////////////////////////

server/tests/server.test.js

...

  // pass in route signature
  describe('DELETE /users/me/token', () => {
    // make sure when real valid x-auth token is passed along to the logout method it actually gets logged out
    it('should remove auth token on logout', (done) => {
      // we need seed data
      request(app)
      // DELETE /users/me/token
        .delete('/users/me/token')
      // Set x-auth to token in tokens array
        .set('x-auth', users[0].tokens[0].token)
      // some assertions
      // expect 200 back
        .expect(200)
      // add async .end() call to make an async assertion
      // find user, verify that tokens array has length of 0
        .end((err, res) => {
          // handle the error
          if (err) {
            return done(err); // pass error to done function
          }
          // query our database
          User.findById(users[1]._id).then((user) => {
            // assertion
            expect(user.tokens.length).toBe(0);
            done();
          }).catch((e) => done(e));
        // }).catch((e) => {
        //   done(e);
        // });
        });

    });
  });

...

































//////////////////////////////////////////////////////////////////
S: 8; P: 99; 'Making Todo routes private pt 1'
//////////////////////////////////////////////////////////////////

add the 'authenticate' middleware to a few routes so we have access to the user and their _creator property which was added to the todos schema













//////////////////////////////////////////////////////////////////
S: 8; P: 100; 'Making Todo routes private pt 2'
//////////////////////////////////////////////////////////////////

routes
  get by id
  delete by id
  patch by id

add 'authenticate' middleware
update our query to take advantage of our new _creator property
update our test cases
