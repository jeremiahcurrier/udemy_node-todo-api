//////////////////////////////////////////////////////////////////
S: 7; P: 60; 'Installing MongoDB and Robomongo'
//////////////////////////////////////////////////////////////////

start up mongodb server (after downloading the .tgz, unzipping, moving to Users directory, renaming folder to mongo and adding new directory called mongo-data which is where we'll write to locally)

// create active connection we can connect to and start manipulating data

cd Users/Jeremiah/mongo/bin

users > jeremiah > mongo > bin > start server

	bin[jeremiah]-$ ./mongod --dbpath ~/mongo-data

		...
		2018-12-27T13:57:19.920-0800 I NETWORK  [initandlisten] waiting for connections on port 27017

// run the mongo file

	bin[jeremiah]-$ ./mongo

		// connects to DB server we just started

		// SET
			> db.Todos.insert({text: 'Create a practice regimen for daily beat exercise'})
			WriteResult({ "nInserted" : 1 })
		// GET
			> db.Todos.find()
			{ "_id" : ObjectId("5c254b9ebb6c4736e30cf943"), "text" : "Create a practice regimen for daily beat exercise" }

			get back a unique identifier and your text property w the value you set

		// shut down the mongo command:
			ctrl+C

now ./mongo is shut off but keep ./mongod running to install one more thing 'Robomongo' which is a GUI for managing your mongo database





















\


//////////////////////////////////////////////////////////////////
S: 7; P: 62; 'Building a NoSQL Vocabulary'
//////////////////////////////////////////////////////////////////


SQL vs NoSQL

Database = contains sets of info.

For SQL you could have a single server with a dozen databases on it. Same is true with MongoDB. No restriction to number of DBs you can setup so you can have TWO applications running on the SAME database server.

SQL   = table-like structure = TABLE
NoSQL = array-like structure = COLLECTION

WEATHER APP
	SQL: Might have a TABLE of users and temps.

		Individual user? 'Row/record'

	NoSQL: Might have a COLLECTION of users and temps.

		Individual user? 'Document'

SQL:NoSQL
::
Table:Collection
::
Row/record:Document(json-like)
::
Columns:Properties


SQL
id | name | email       | password
1  | john | foo@bar.com | 1234...

'schema-based' i.e. the 'name'(etc) column(s) exists for ALL records, of a specific type, and guarenteed to be there for all rows/records in this table.


NoSQL
documents in a collection do NOT need to have all the same properties i.e. two documents can have different properties.


SQL:column::NoSQL:field






















//////////////////////////////////////////////////////////////////
S: 7; P: 63; 'Connecting to Mongo and writing data'
//////////////////////////////////////////////////////////////////



insert/update/read/delete (CRUD) our 'todo list' data in mongodb

BASICS

https://github.com/mongodb/node-mongodb-native


connect to mongo db in node.js
npm module created by mongo team





node-todo-api[jeremiah]-$ node playground/mongodb-connect.js
Connected to MongoDB server

node-todo-api[jeremiah]-$






playground/mongodb-connect.js


	// mongo client to connect to mongo server
	const MongoClient = require('mongodb').MongoClient;

	// url (aws/heroku in prod) and callback post connection
	MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
		// handle errors
		if (err) {
			// using 'return' to prevent further code execution
			return console.log('Unable to connect to MongoDB server');
		}
		console.log('Connected to MongoDB server');
		const db = client.db('TodoApp') // 'db' reference

		// insert new record/document in a collection
		// insertOne takes an object and
		// a callback (err, result) only 1 returned
		db.collection('Todos').insertOne({
			// obj w key value pairs for document
			text: 'Something to do',
			completed: false
		}, (err, result) => {
			if (err) {
				return console.log('Unable to insert todo', err);
			}
			// result.ops = ops stores docs inserted
			// undefined = for filter function
			// 2 = indentation
			console.log(JSON.stringify(result.ops, undefined, 2));
		});

		client.close(); // to close connection with mongodb server
	});








		// mongo client to connect to mongo server
		const MongoClient = require('mongodb').MongoClient;

		// url (aws/heroku in prod) and callback post connection
		MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
			// handle errors
			if (err) {
				// using 'return' to prevent further code execution
				return console.log('Unable to connect to MongoDB server');
			}
			console.log('Connected to MongoDB server');
			const db = client.db('TodoApp') // 'db' reference

			// insert new record/document in a collection
			// insertOne takes an object and
			// a callback (err, result) only 1 returned
			// db.collection('Todos').insertOne({
			// 	// obj w key value pairs for document
			// 	text: 'Something to do',
			// 	completed: false
			// }, (err, result) => {
			// 	if (err) {
			// 		return console.log('Unable to insert todo', err);
			// 	}
			// 	// result.ops = ops stores docs inserted
			// 	// undefined = for filter function
			// 	// 2 = indentation
			// 	console.log(JSON.stringify(result.ops, undefined, 2));
			// });

			// Insert new doc into the Users collection (name, age, location)
			db.collection('Users').insertOne({
				name: 'Jeremiah',
				age: 32,
				location: 'San Francisco'
			}, (err, result) => {
				// foo
				if (err) {
					return console.log('Unable to insert user', err);
				}
				console.log(JSON.stringify(result.ops, undefined, 2));
			});

			client.close(); // to close connection with mongodb server
		});
























//////////////////////////////////////////////////////////////////
S: 7; P: 64; 'The ObjectId'
//////////////////////////////////////////////////////////////////

node-todo-api[jeremiah]-$ node playground/mongodb-connect.js
Connected to MongoDB server
[
  {
    "name": "Jeremiah",
    "age": 32,
    "location": "San Francisco",
    "_id": "5c255810c748f57b593a98b0"
  }
]


ObjectId
	12 byte value
		first 4 bytes = timestamp id was created
		next 3 bytes = machine identifier (ensure id is unique)
		next 2 bytes = process id
		last 3 byte = similar to MySQL

	no need to add a created_at timestamp

YOU CAN SET the ObjectId if you want to set your own id creation value


how to access embedded timestamp of auto-generated ObjectId?

		// console.log(JSON.stringify(result.ops, undefined, 2));
		// console.log(result.ops[0]._id);
		console.log(result.ops[0]._id.getTimestamp()); // THIS




ES6 destructuring is a great way to make new variables set to the value of an objects property

	// ES6 'object destructuring' - pull out obj props creating vars
	var user = {name: 'Jeremiah', age: 32};
	var {name} = user;
	/* destructured 'user' obj pulling off 'name' property
	creating a new 'name' variable and setting it
	equal to whatever the value is */
	console.log(name);





// const MongoClient = require('mongodb').MongoClient;
const {MongoClient, ObjectID} = require('mongodb');
/* pulled out ObjectID constructor function
which lets us create new objectId on the fly. Even
if not using MongDB there is value is being able to
uniquely identify things*/

var obj = new ObjectID(); // create new instance of ObjectID
console.log(obj); // technique to incorporate objId anyway we like




playground/mongodb-connect.js

		// const MongoClient = require('mongodb').MongoClient;
		const {MongoClient, ObjectID} = require('mongodb');
		/* pulled out ObjectID constructor function
		which lets us create new objectId on the fly. Even
		if not using MongDB there is value is being able to
		uniquely identify things*/

		var obj = new ObjectID(); // create new instance of ObjectID
		console.log(obj); // technique to incorporate objId anyway we like

		MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
			if (err) {
				return console.log('Unable to connect to MongoDB server');
			}
			console.log('Connected to MongoDB server');
			const db = client.db('TodoApp') // 'db' reference

			// db.collection('Todos').insertOne({
			// 	text: 'Something to do',
			// 	completed: false
			// }, (err, result) => {
			// 	if (err) {
			// 		return console.log('Unable to insert todo', err);
			// 	}
			// 	console.log(JSON.stringify(result.ops, undefined, 2));
			// });

			// db.collection('Users').insertOne({
			// 	// _id: 123,
			// 	name: 'Jeremiah',
			// 	age: 32,
			// 	location: 'San Francisco'
			// }, (err, result) => {
			// 	if (err) {
			// 		return console.log('Unable to insert user', err);
			// 	}
			// 	// console.log(JSON.stringify(result.ops, undefined, 2));
			// 	// console.log(result.ops[0]._id);
			// 	console.log(result.ops[0]._id.getTimestamp());
			// });

			client.close();
		});





















//////////////////////////////////////////////////////////////////
S: 7; P: 65; 'Fetching data'
//////////////////////////////////////////////////////////////////



new file 'mondodb-find.js'

		// const MongoClient = require('mongodb').MongoClient;
		const {MongoClient, ObjectID} = require('mongodb');

		MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
			if (err) {
				return console.log('Unable to connect to MongoDB server');
			}
			console.log('Connected to MongoDB server');
			const db = client.db('TodoApp') // 'db' reference

			// db.collection('Todos').find() // returns CURSOR
			// db.collection('Todos').find().toArray() // returns promise

			// // fetch docs, convert to array, and print to screen
			// db.collection('Todos').find().toArray().then((docs) => {
			// 	console.log('Todos');
			// 	console.log(JSON.stringify(docs, undefined, 2));
			// }, (err) => {
			// 	console.log('Unable to fetch todos', err);
			// });

			// // how to query based on certain values?
			// // specify how to query 'todos' collection
			// db.collection('Todos').find({completed: true}).toArray().then((docs) => {
			// 	console.log('Todos');
			// 	console.log(JSON.stringify(docs, undefined, 2));
			// }, (err) => {
			// 	console.log('Unable to fetch todos', err);
			// });

			// query by '_id' value ??? (below is wrong)
			// db.collection('Todos').find({_id: '5c2556c653e9287a39a4e73a'}).toArray().then((docs) => {
			// 	console.log('Todos');
			// 	console.log(JSON.stringify(docs, undefined, 2));
			// }, (err) => {
			// 	console.log('Unable to fetch todos', err);
			// });

			// QUERY the items by object ID
			// NOW YOU CAN USE THE OBJECT ID CONSTRUCTOR FROM BEFORE
			// TO QUERY BY 'OBJECTID'
			/* query todo collection looking for any records
			that have an _id property equal to
			'5c2556c653e9287a39a4e73a'
			*/
			// db.collection('Todos').find({
			// 	_id: new ObjectID('5c2556c653e9287a39a4e73a')
			// }).toArray().then((docs) => {
			// 	console.log('Todos');
			// 	console.log(JSON.stringify(docs, undefined, 2));
			// }, (err) => {
			// 	console.log('Unable to fetch todos', err);
			// });

			// // COUNT the items
			// db.collection('Todos').find().count().then((count) => {
			// 	console.log(`Todos count: ${count}`);
			// }, (err) => {
			// 	console.log('Unable to fetch todos', err);
			// });

			// query all users where name is 'Jeremiah' in Users collection
			db.collection('Users').find({name: 'Jeremiah'}).toArray().then((users) => {
				console.log('Users');
				console.log(JSON.stringify(users, undefined, 2));
			}, (err) => {
				console.log('Unable to find any users', err);
			});



			// client.close();
		});






















//////////////////////////////////////////////////////////////////
S: 7; P: 67; 'Deleting documents'
//////////////////////////////////////////////////////////////////

how to delete docs from your mongodb collections

multiple or just one

there are 86 lessons at the end of section 7

~ 180 minutes or with padding 240 (6 * 3 become 6 * 4)
240 minutes = 4 hours (tomorrow 6am-10am completion of section 7)

then section 8 = over the weekend if possible?



===mongodb-delete.js===



		// const MongoClient = require('mongodb').MongoClient;
		const {MongoClient, ObjectID} = require('mongodb');

		MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
			if (err) {
				return console.log('Unable to connect to MongoDB server');
			}
			console.log('Connected to MongoDB server');
			const db = client.db('TodoApp') // 'db' reference

			// // deleteMany (many documents)
			// db.collection('Todos').deleteMany({text: 'Eat lunch'}).then((result) => {
			// 	// if (err) {
			// 	// 	return console.log('Error deleting many documents', err);
			// 	// }
			// 	console.log(result);
			// 	/* response is huge but all
			// 	you need is the 'result' object
			// 	i.e.
			// 	result: { n: 3, ok: 1 },
			// 	'result' obj includes 'n' and 'ok'
			// 	properties
			// 	*/
			// });

			// // deleteOne (1 doc)
			// db.collection('Todos').deleteOne({text: 'Eat lunch'}).then((result) => {
			// 	// if (err) {
			// 	// 	return console.log('Error deleting one document', err);
			// 	// }
			// 	console.log(result);
			// 	/* 'result' obj includes 'n' and 'ok'
			// 	properties */
			// });

			// // findOneAndDelete (remove item and return value/obj back)
			// db.collection('Todos').findOneAndDelete({completed: false}).then((result) => {
			// 	// if (err) {
			// 	// 	return console.log('Error finding and deleting one', err);
			// 	// }
			// 	/* instead of just getting
			// 	a 'result' obj with 'n' and 'ok'
			// 	properties you actually get the
			// 	entire document back */
			// 	console.log(result);
			// });


		// CHALLENGE
			// // deleteMany (many documents)
			// db.collection('Users').deleteMany({name: 'Jeremiah'}).then((result) => {
			// 	console.log(result);
			// });
		// success
		// another option
			// // // deleteMany (many documents)
			// db.collection('Users').deleteMany({name: 'Jeremiah'});


		// //CHALLENGE
		// 	db.collection('Users').findOneAndDelete({
		// 		_id: new ObjectID('5c255810c748f57b593a98b0')
		// 	}).then((result) => {
		// 		console.log(result);
		// 	});
		// // success


			// client.close();
		});












//////////////////////////////////////////////////////////////////
S: 7; P: 68; 'Updating data'
//////////////////////////////////////////////////////////////////


===mongodb-update.js===


		// const MongoClient = require('mongodb').MongoClient;
		const {MongoClient, ObjectID} = require('mongodb');

		MongoClient.connect('mongodb://localhost:27017/TodoApp', { useNewUrlParser: true }, (err, client) => {
			if (err) {
				return console.log('Unable to connect to MongoDB server');
			}
			console.log('Connected to MongoDB server');
			const db = client.db('TodoApp');

			/*
			findOneAndUpdate(filter, update, options, callback)
			https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndUpdate/
			returns a promise
			*/
				/* mongodb update operators
				https://docs.mongodb.com/manual/reference/operator/update/
				will work with all drivers
				including node.js driver for mongodb
				we want the 'SET' operators
				$INC is another good one to increment a number value
				*/

			// // findOneAndUpdate (update item and return new document)
			// db.collection('Todos').findOneAndUpdate({
				// _id: new ObjectID('5c266d2e6cd2860837ca6eb7')
			// }, {
			// 	$set: {
			// 		completed: true
			// 	}
			// }, {
			// 	returnOriginal: false
			// }).then((result) => {
			// 	console.log(result);
			// 	// includes 'value' prop in response
			// });

			// findOneAndUpdate (name and age)
			db.collection('Users').findOneAndUpdate({
				name: 'Jaaay'
				// _id: new ObjectID('5c266d2e6cd2860837ca6eb7')
			}, {
				// $set: {
				// 	name: 'Jaaay'
				// },
				$inc: {
					// age: +1
					age: 1
				}
			}, {
				returnOriginal: false
			}).then((result) => {
				console.log(result);
				// check value prop...
			});

			// client.close();
		});

		/* the real goal is you writing your own code,
		doing your own research, and reading your
		own documentation */







//////////////////////////////////////////////////////////////////
S: 7; P: 69; 'The Mongoose ORM'
//////////////////////////////////////////////////////////////////


Learned to use MongoDB NATIVE driver for CRUD to documents.

Mongoose = ORM (object relational library) = easy to structure data.

A 'todo' needs properties of types, maybe custom validation, validate user password etc. Easier with Mongoose. Possible with MongoDB native driver but better to not reinvent the wheel.



























//////////////////////////////////////////////////////////////////
S: 7; P: 70; 'Setting up Mongoose'
//////////////////////////////////////////////////////////////////

An ORM maps between an Object Model and a Relational Database. An ODM maps between an Object Model and a Document Database. MySQL is not an ORM, it's a Relational Database, more specifically, a SQL Database. MongoDB is not an ODM, it's a Document Database.

yay! time to leave the playground folder

1. connect to mdb
2. create a model
3. talk about what a model is
4. save data to db using mongoose

essential mongoose features

$ npm i mongoose@4.5.9 --save

start creating files we need for our application




=== server/server.js ===





// get everything ready to go

// load in mongoose
var mongoose = require('mongoose');

// callbacks are not as simple to chain/manage/scale as promises
// promises came from 'bluebird'
mongoose.Promise = global.Promise;

// connect to db
// mongoose maintains connection over time
mongoose.connect('mongodb://localhost:27017/TodoApp');

// save new something - no time (ms) for db to connect
// behind scenes mongoose waits for connection before making query
// no need to micromanage order things happen

// create a MODEL
// collections can store anything
// create a 'todo' model with attributes
// so mongo knows how to store our data
var Todo = mongoose.model('Todo', {
	// defines the props for this model
	// required/validators/type
	text: {
		type: String
	},
	completed: {
		type: Boolean
	},
	completedAt: {
		type: Number
	}
	// createdAt? No. Mongodb timestamp has that
});




// === ONE
// how to CREATE an INSTANCE of a 'Todo'?
// run as a constructor function bc creating new instance
// takes an arg including specified props
// var newTodo = new Todo({
// 	text: 'Cook dinner'
// });

// how to save to database??
/* ...creating new instance alone does not
update mongodb database. we need to call method on
newTodo which is newTodo.save to save to mongodb
database.
returns a promise
tack on a .then() and include error handling (connection
failed, wrong type etc)
*/

// newTodo.save().then((doc) => {
// 	console.log('Saved todo', doc);
// }, (e) => {
// 	console.log('Unable to save todo');
// });
// Saved todo { __v: 0, text: 'Cook dinner', _id: 5c267898311f08e9c6e454aa }




// === TWO
// var newTodo2 = new Todo({
// 	text: 'Cook dinner 2',
// 	completed: false,
// 	// completedAt: 123 (2 minutes into year 1970)
// 	completedAt:
// });

// newTodo2.save().then((doc) => {
// 	console.log('Saved todo', doc);
// }, (e) => {
// 	console.log('Unable to save todo');
// });




// === THREE
var newTodo3 = new Todo({
	text: 'Cook dinner 3',
	completed: true,
	// completedAt: 123 (2 minutes into year 1970)
	completedAt: 123
});

newTodo3.save().then((doc) => {
	// console.log('Saved todo', doc);
	console.log(JSON.stringify(doc, undefined, 2));
}, (e) => {
	console.log('Unable to save todo');
});


















//////////////////////////////////////////////////////////////////
S: 7; P: 71; 'Validators, Types, and Defaults'
//////////////////////////////////////////////////////////////////

another application could be a web app, a mobile, or another server (like your slack app you built hosted in a clients private cloud infrastructure running on AWS rails)

server/server.js

    // get everything ready to go

    // load in mongoose
    var mongoose = require('mongoose');

    // callbacks are not as simple to chain/manage/scale as promises
    // promises came from 'bluebird'
    mongoose.Promise = global.Promise;

    // connect to db
    // mongoose maintains connection over time
    mongoose.connect('mongodb://localhost:27017/TodoApp');

    // save new something - no time (ms) for db to connect
    // behind scenes mongoose waits for connection before making query
    // no need to micromanage order things happen

    // create a MODEL
    // collections can store anything
    // create a 'todo' model with attributes
    // so mongo knows how to store our data
    var Todo = mongoose.model('Todo', {
    	// defines the props for this model
    	// required/validators/type
    	text: {
    		type: String,
    		required: true
    	},
    	completed: {
    		type: Boolean
    	},
    	completedAt: {
    		type: Number
    	}
    	// createdAt? No. Mongodb timestamp has that
    });




    // === ONE
    // how to CREATE an INSTANCE of a 'Todo'?
    // run as a constructor function bc creating new instance
    // takes an arg including specified props
    // var newTodo = new Todo({
    // 	text: 'Cook dinner'
    // });

    // how to save to database??
    /* ...creating new instance alone does not
    update mongodb database. we need to call method on
    newTodo which is newTodo.save to save to mongodb
    database.
    returns a promise
    tack on a .then() and include error handling (connection
    failed, wrong type etc)
    */

    // newTodo.save().then((doc) => {
    // 	console.log('Saved todo', doc);
    // }, (e) => {
    // 	console.log('Unable to save todo');
    // });
    // Saved todo { __v: 0, text: 'Cook dinner', _id: 5c267898311f08e9c6e454aa }




    // === TWO
    // var newTodo2 = new Todo({
    // 	text: 'Cook dinner 2',
    // 	completed: false,
    // 	// completedAt: 123 (2 minutes into year 1970)
    // 	completedAt:
    // });

    // newTodo2.save().then((doc) => {
    // 	console.log('Saved todo', doc);
    // }, (e) => {
    // 	console.log('Unable to save todo');
    // });

    // === THREE
    var newTodo3 = new Todo({
    	text: 'Cook dinner 3',
    	completed: true,
    	// completedAt: 123 (2 minutes into year 1970)
    	completedAt: 123
    });

    newTodo3.save().then((doc) => {
    	// console.log('Saved todo', doc);
    	console.log(JSON.stringify(doc, undefined, 2));
    }, (e) => {
    	console.log('Unable to save todo');
    });




-





server.js

    var mongoose = require('mongoose');

    mongoose.Promise = global.Promise;
    mongoose.connect('mongodb://localhost:27017/TodoApp');

    var Todo = mongoose.model('Todo', {
    	text: {
    		type: String,
    		required: true,
    		minLength: 1,
    		trim: true
    	},
    	completed: {
    		type: Boolean,
    		default: false
    	},
    	completedAt: {
    		type: Number,
    		default: null
    	}
    });

    var User = mongoose.model('User', {
    	email: {
    		type: String,
    		required: true,
    		trim: true,
    		minLength: 1
    	}
    });

    // var newTodo = new Todo({
    // 	text: 'Cook dinner'
    // });

    // newTodo.save().then((doc) => {
    // 	console.log('Saved todo', doc);
    // }, (e) => {
    // 	console.log('Unable to save todo');
    // });

    // var otherTodo = new Todo({
    // 	text: 'Something to do'// if you put a number or boolean mongoose will turn either into a string
    // });


    // otherTodo.save().then((doc) => {
    // 	console.log(JSON.stringify(doc, undefined, 2));
    // }, (e) => {
    // 	console.log('Unable to save', e);
    // });

    // User
    // email - require it - trim it - set type string - set minlengh 1

    var user = new User({
    	email: 'hello@world.com'
    });

    user.save().then((doc) => {
    	console.log('User saved', doc);
    }, (e) => {
    	console.log('Unable to save user', e);
    });























//////////////////////////////////////////////////////////////////
S: 7; P: 73; 'Resource creation endpoint - POST /todos'
//////////////////////////////////////////////////////////////////

only thing that should be in server.js is our Express route handlers




CURRENT server.js

        var mongoose = require('mongoose');

        mongoose.Promise = global.Promise;
        mongoose.connect('mongodb://localhost:27017/TodoApp');

        var Todo = mongoose.model('Todo', {
        	text: {
        		type: String,
        		required: true,
        		minLength: 1,
        		trim: true
        	},
        	completed: {
        		type: Boolean,
        		default: false
        	},
        	completedAt: {
        		type: Number,
        		default: null
        	}
        });

        var User = mongoose.model('User', {
        	email: {
        		type: String,
        		required: true,
        		trim: true,
        		minLength: 1
        	}
        });

        // var newTodo = new Todo({
        // 	text: 'Cook dinner'
        // });

        // newTodo.save().then((doc) => {
        // 	console.log('Saved todo', doc);
        // }, (e) => {
        // 	console.log('Unable to save todo');
        // });

        // var otherTodo = new Todo({
        // 	text: 'Something to do'// if you put a number or boolean mongoose will turn either into a string
        // });


        // otherTodo.save().then((doc) => {
        // 	console.log(JSON.stringify(doc, undefined, 2));
        // }, (e) => {
        // 	console.log('Unable to save', e);
        // });

        // User
        // email - require it - trim it - set type string - set minlengh 1

        var user = new User({
        	email: 'hello@world.com'
        });

        user.save().then((doc) => {
        	console.log('User saved', doc);
        }, (e) => {
        	console.log('Unable to save user', e);
        });



UPDATED server.js


    /* pull off 'mongoose' property using es6 destructuring
    creating a local variable called 'mongoose' equal to
    the 'mongoose' property on the object and that object
    is the return result from requiring the file
    ./db/mongoose.js */
    var {mongoose} = require('./db/mongoose');

    //
    // var user = new User({
    // 	email: 'hello@world.com'
    // });
    //
    // user.save().then((doc) => {
    // 	console.log('User saved', doc);
    // }, (e) => {
    // 	console.log('Unable to save user', e);
    // });



UPDATED UPDATED server.js

    var {mongoose} = require('./db/mongoose');
    var {Todo} = require('./models/todo');
    var {User} = require('./models/user');

body-parser = lets us send JSON of response string body and turns into js obj

npm i express body-parser --save






// library imports
var express = require('express'); // store express library
var bodyParser = require('body-parser'); // store body-parser library
// local imports
var {mongoose} = require('./db/mongoose');
var {Todo} = require('./models/todo');
var {User} = require('./models/user');

var app = express();

// configure routes
/* POST route (new todo/user send JSON obj to server w text property and server will get text property create model with other properties and send todo/user back to client) */
app.post('/todos', (req, res) => {
	//foo
});

app.listen(3000, () => {
	console.log('Started on port 3000');;
});







server.js



    var express = require('express');
    var bodyParser = require('body-parser');

    var {mongoose} = require('./db/mongoose');
    var {Todo} = require('./models/todo');
    var {User} = require('./models/user');

    var app = express();

    // configure middleware
    app.use(bodyParser.json()); // can now send JSON to express application

    app.post('/todos', (req, res) => {
    	// get body data sent by the client (Slack Events API could be client)
    	// console.log(req.body);
    	var todo = new Todo({
    		text: req.body.text
    	});

    	todo.save().then((doc) => { // save todo to db
    		// s
    		res.send(doc);
    	}, (e) => {
    		// e
    		res.status(400).send(e);
    		// https://httpstatuses.com/400
    	});
    });

    app.listen(3000, () => {
    	console.log('Started on port 3000');;
    });




























		//////////////////////////////////////////////////////////////////
		S: 7; P: 74; 'Testing POST /todos'
		//////////////////////////////////////////////////////////////////



		server.js


		      var express = require('express');
		      var bodyParser = require('body-parser');

		      var {mongoose} = require('./db/mongoose');
		      var {Todo} = require('./models/todo');
		      var {User} = require('./models/user');

		      var app = express();

		      app.use(bodyParser.json());

		      // expect = assertions
		      // mocha = entire test suite
		      // supertest = to test express routes
		      // nodemon = lets us create test-watch script we had so we can automatically restart the test suite - nodemon is installed globally but since using inside a package.json script = good idea to install locally as well
		      // 1 - verify if send correct data as body we get back 200 w completed doc including the id
		      // 2 - if we send bad data expect 400 with error obj
		      app.post('/todos', (req, res) => {
		      	var todo = new Todo({
		      		text: req.body.text
		      	});

		      	todo.save().then((doc) => {
		      		res.send(doc);
		      	}, (e) => {
		      		res.status(400).send(e);
		      	});
		      });

		      app.listen(3000, () => {
		      	console.log('Started on port 3000');;
		      });

		      module.exports = {app};


		server.test.js

		      // require supertest and expect - nodemon and mocha do not need to be required that is not how they are used
		      const expect = require('expect');
		      const request = require('supertest');
		      // local files
		      const {app} = require('./../server');
		      const {Todo} = require('./../models/todo');

		      // add TESTING LIFECYCLE METHOD
		      beforeEach((done) => {
		        // run before every test case
		        Todo.remove({}).then(() => done()); // wipe out our todos
		      });

		      // group all routes
		      describe('POST /todos', () => {
		        it('should create a new todo', (done) => {
		          var text = 'Test todo text';

		          request(app)
		            .post('/todos')
		            .send({text})
		            .expect(200)
		            .expect((res) => {
		              expect(res.body.text).toBe(text);
		            })
		            .end((err, res) => {
		              // handle any errors that occured above &&
		              if (err) {
		                return done(err); // return result to stop f(x) execution
		              }

		              // request to db fetch todos verifying one was added
		              Todo.find().then((todos) => {
		                expect(todos.length).toBe(1);
		                expect(todos[0].text).toBe(text);
		                done();
		              }).catch((e) => done(e));
		            });
		        });

		      // verify todo does not get created if we send bad data expect 400 with error obj
		        it('should not create todo with invalid body data', (done) => {
		          request(app)
		            .post('/todos')
		            .send({})
		            .expect(400)
		            .end((err, res) => {
		              if (err) {
		                return done(err);
		              }

		              Todo.find().then((todos) => {
		                expect(todos.length).toBe(0);
		                done();
		              }).catch((e) => done(e));
		            });
		        })

		      });









































					//////////////////////////////////////////////////////////////////
					S: 7; P: 75; 'List Resources GET /todos'
					//////////////////////////////////////////////////////////////////


					server.js

					      var express = require('express');
					      var bodyParser = require('body-parser');

					      var {mongoose} = require('./db/mongoose');
					      var {Todo} = require('./models/todo');
					      var {User} = require('./models/user');

					      var app = express();

					      app.use(bodyParser.json());

					      app.post('/todos', (req, res) => {
					      	var todo = new Todo({
					      		text: req.body.text
					      	});

					      	todo.save().then((doc) => {
					      		res.send(doc);
					      	}, (e) => {
					      		res.status(400).send(e);
					      	});
					      });

					      app.get('/todos', (req, res) => {
					      	Todo.find().then((todos) => {
					      		res.send({todos}); // create an object so you can add properties later on VS sending an Array back. More flexible future
					      	}, (e) => {
					      		// e
					      		res.status(400).send(e);
					      	});
					      });

					      app.listen(3000, () => {
					      	console.log('Started on port 3000');;
					      });

					      module.exports = {app};



					server.test.js


					      // require supertest and expect - nodemon and mocha do not need to be required that is not how they are used
					      const expect = require('expect');
					      const request = require('supertest');
					      // local files
					      const {app} = require('./../server');
					      const {Todo} = require('./../models/todo');


					      // ADD SEED DATA
					      // dummy todos
					      const todos = [{
					        text: 'First test todo'
					      }, {
					        text: 'Second test todo'
					      }];


					      // add TESTING LIFECYCLE METHOD
					      beforeEach((done) => {
					        // run before every test case
					        // Todo.remove({}).then(() => done()); // wipe out our todos
					        // insertMany (takes array and inserts into collection)
					        Todo.remove({}).then(() => {
					          return Todo.insertMany(todos);
					        }).then(() => done());
					      });

					      // group all routes
					      describe('POST /todos', () => {
					        it('should create a new todo', (done) => {
					          var text = 'Test todo text';

					          request(app)
					            .post('/todos')
					            .send({text})
					            .expect(200)
					            .expect((res) => {
					              expect(res.body.text).toBe(text);
					            })
					            .end((err, res) => {
					              // handle any errors that occured above &&
					              if (err) {
					                return done(err); // return result to stop f(x) execution
					              }

					              // request to db fetch todos verifying one was added
					              Todo.find({text}).then((todos) => {
					                expect(todos.length).toBe(1);
					                expect(todos[0].text).toBe(text);
					                done();
					              }).catch((e) => done(e));
					            });
					        });

					      // verify todo does not get created if we send bad data expect 400 with error obj
					        it('should not create todo with invalid body data', (done) => {
					          request(app)
					            .post('/todos')
					            .send({})
					            .expect(400)
					            .end((err, res) => {
					              if (err) {
					                return done(err);
					              }

					              Todo.find().then((todos) => {
					                expect(todos.length).toBe(2);
					                done();
					              }).catch((e) => done(e));
					            });
					        })

					      });

					      describe('GET /todos', () => {
					        it('should get all todos', (done) => {
					          request(app)
					            .get('/todos')
					            .expect(200)
					            .expect((res) => {
					              expect(res.body.todos.length).toBe(2);
					            })
					            .end(done);
					        });
					      });




























//////////////////////////////////////////////////////////////////
S: 7; P: 76; 'Mongoose Queries and ID Validation'
//////////////////////////////////////////////////////////////////

								/playground/mongoose-queries.js

								    // load in the objectId from the mongoDB native driver
								    const {ObjectID} = require('mongodb');

								    const {mongoose} = require('./../server/db/mongoose');
								    const {Todo} = require('./../server/models/todo');
								    const {User} = require('./../server/models/user');

								    // var id = '5c32654552234b473b76fd1311';

								    // if (!ObjectID.isValid(id)) {
								    //   console.log('ID not valid');
								    // }

								    // // returns ARRAY
								    // Todo.find({
								    //   _id: id // mongoose take this string > convert to obj id > run query
								    // }).then((todos) => {
								    //   console.log('Todos', todos);
								    // });
								    //
								    // // first matching doc from mongo
								    // // returns OBJECT
								    // Todo.findOne({
								    //   _id: id // mongoose take this string > convert to obj id > run query
								    // }).then((todo) => {
								    //   console.log('Todo', todo);
								    // });

								    // Todo.findById(id).then((todo) => {
								    //   if (!todo) {
								    //     return console.log('Id not found');
								    //   }
								    //   console.log('Todo By Id', todo);
								    // }).catch((e) => console.log(e));


								    User.findById('5c31558e9e651b4307cef9af').then((user) => {
								      if (!user) {
								        return console.log('User not found');
								      }
								      // pretty print to console
								      console.log(JSON.stringify(user, undefined, 2));
								    }, (e) => {
								      console.log(e);
								    });


























										//////////////////////////////////////////////////////////////////
										S: 7; P: 78; 'Getting an individual resource - GET /todos/:id'
										//////////////////////////////////////////////////////////////////


										server.js

										    var express = require('express');
										    var bodyParser = require('body-parser');

										    var {mongoose} = require('./db/mongoose');
										    var {Todo} = require('./models/todo');
										    var {User} = require('./models/user');
										    // load in the objectId from the mongoDB native driver
										    var {ObjectID} = require('mongodb');

										    var app = express();

										    app.use(bodyParser.json());

										    app.post('/todos', (req, res) => {
										    	var todo = new Todo({
										    		text: req.body.text
										    	});

										    	todo.save().then((doc) => {
										    		res.send(doc);
										    	}, (e) => {
										    		res.status(400).send(e);
										    	});
										    });

										    app.get('/todos', (req, res) => {
										    	Todo.find().then((todos) => {
										    		res.send({todos}); // create an object so you can add properties later on VS sending an Array back. More flexible future
										    	}, (e) => {
										    		// e
										    		res.status(400).send(e);
										    	});
										    });

										    // GET /todos/123123
										    app.get('/todos/:id', (req, res) => {
										    	var id = req.params.id;

										    	if (!ObjectID.isValid(id)) {
										    		return res.status(404).send();
										    	}
										    	// validate id using isValid
										    		// if not stop respond 404 - send empty body .send();

										    		Todo.findById(id).then((todo) => {
										    		  if (!todo) {
										    		    // return console.log('Id not found');
										    				// return res.status(404).send();
										    				return res.status(404).send();
										    		  }

										    		  // console.log('Todo By Id', todo);
										    			res.send({todo});
										    		}).catch((e) => {
										    			res.status(400).send();
										    		});
										    	// query db using findById query todos collections
										    		// s
										    			// if todo - send it back
										    			// if no todo - call good - no id in collection send 404 with empty body
										    		// e
										    			// 400 - could contain private information and send empty body back

										    	// res.send(req.params);
										    });

										    app.listen(3000, () => {
										    	console.log('Started on port 3000');;
										    });

										    module.exports = {app};
