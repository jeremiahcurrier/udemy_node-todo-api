//////////////////////////////////////////////////////////////////
S: 7; P: 85; 'Testing PATCH /todos/:id'
//////////////////////////////////////////////////////////////////

new describe block in server.test.js

  describe('PATCH /todos/:id', () => {
    // 2 test cases
    // take our 1st todo and set text to something else and completed from false to true
    it('should update the todo', (done) => {
      // grab id of first item
      var hexId = todos[0]._id.toHexString();
      var text = 'This should be the new text';
        // make request to express application
        request(app)
          .patch(`/todos/${hexId}`) // url with template string
          .send({
            // send data before making assertions
            completed: true,
            // text: text
            text // es6
          })
          .expect(200) // assert 200
          .expect((res) => {
            expect(res.body.todo.text).toBe(text);
            expect(res.body.todo.completed).toBe(true);
            expect(typeof res.body.todo.completedAt).toBe('number');
          })
          // BEFORE CUSTOM ASSERTION - call end
          .end(done);
    });

    // toggling that completed value for the second todo
    it('should clear completedAt when todo is not completed', (done) => {
      // grab id of second item
      var hexId = todos[1]._id.toHexString();
      var text = 'patched up real nice';
      // make request to express application
      request(app)
        .patch(`/todos/${hexId}`)
        // send the data before you can make the assertion about its response
        .send({
          text,
          completed: false
        })
        // expect http 200 ok
        .expect(200)
        // custom assertion text changed, completed false, completedAt is null via .toNotExist
        .expect((res) => {
          // custom assertions here
          expect(res.body.todo.text).toBe(text);
          expect(res.body.todo.completed).toBe(false);
          expect(res.body.todo.completedAt).toBeFalsy();
        })
        .end(done);
    });
  });









server.js

logic for PATCH

    app.patch('/todos/:id', (req, res) => {
    	var id = req.params.id;
    	var body = _.pick(req.body, ['text', 'completed']); // has subset of things user passed to us and we only want to PICK some things for the user to be able to update.

    	if (!ObjectID.isValid(id)) {
    		return res.status(404).send();
    	}

    	// checking completed value and setting completedAt (timestamp or cleared)
    	if(_.isBoolean(body.completed) && body.completed) {
    		body.completedAt = new Date().getTime(); // num ms on midnight of jan 1st since 1970 epoch-epic
    	} else {
    		// not boolean and or not true
    		body.completed = false;
    		body.completedAt = null; // remove form db = null
    	}

    	// query to update db
    	Todo.findByIdAndUpdate(id, {$set: body}, {new: true}).then((todo) => { // use mongoDb operators (like incrementors or $set)
    		if (!todo) {
    			return res.status(404).send();
    		}

    		// res.send({todo: todo});
    		res.send({todo}); // es6 syntax
    		// success
    	}).catch((e) => {
    		res.status(400).send();
    	});
    });

    app.listen(port, () => {
    	console.log(`Started on port ${port}`);
    });

    module.exports = {app};






//////////////////////////////////////////////////////////////////
S: 7; P: 86; 'Creating a test database'
//////////////////////////////////////////////////////////////////


process.env.NODE_ENV === 'production' // default (app on Heroku)
process.env.NODE_ENV === 'development' // run app locally
process.env.NODE_ENV === 'test' // run app through mocha

server/config/config.js

  var env = process.env.NODE_ENV || 'development';

  if (env === 'development') {
  	// setup mongoDB url
  	process.env.PORT === 3000;
  	process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoApp';
  } else if (env === 'test') {
  	// also wanna setup custom DB url
  	process.env.PORT === 3000;
  	process.env.MONGODB_URI = 'mongodb://localhost:27017/TodoAppTest';
  }


package.json

  {
    "name": "todo-api",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "start": "node server/server.js",
      "test": "export NODE_ENV=test || \"SET NODE_ENV=test\" && mocha server/**/*.test.js",
      "test-watch": "nodemon --exec 'npm test'"
    },
    "engines": {
      "node": "10.9.0"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jeremiahcurrier/udemy_node-todo-api.git"
    },
    "author": "",
    "license": "ISC",
    "bugs": {
      "url": "https://github.com/jeremiahcurrier/udemy_node-todo-api/issues"
    },
    "homepage": "https://github.com/jeremiahcurrier/udemy_node-todo-api#readme",
    "dependencies": {
      "body-parser": "^1.18.3",
      "express": "^4.16.4",
      "lodash": "^4.17.11",
      "mongodb": "^3.1.10",
      "mongoose": "^4.5.9"
    },
    "devDependencies": {
      "expect": "^23.6.0",
      "mocha": "^5.2.0",
      "nodemon": "^1.18.9",
      "supertest": "^3.3.0"
    }
  }




  //////////////////////////////////////////////////////////////////
  Security and Authentication
  S: 8; P: 88; 'Setting up the User Model'
  //////////////////////////////////////////////////////////////////

  server/models/user.js

    const mongoose = require('mongoose');
    const validator = require('validator');

    // how could a database get compromised?

    var User = mongoose.model('User', {
    	email: {
    		type: String,
    		required: true,
    		trim: true,
    		minLength: 1,
    		unique: true, // prevents another user in db from same email
    		validate: {
    			// validator: (value) => {
    			// 	// call function
    			// 	return validator.isEmail(value);
    			// },
    			validator: validator.isEmail,
    			message: '{VALUE} is not a valid email'
    		}
    	},
    	password: {
    		type: String,
    		require: true,
    		minLength: 6
    	},
    // nested document available in mongo NOT in postgres - tokens is array - feature in mongo only
    	tokens: [{
    		access: {
    			// code
    			type: String,
    			required: true
    		},
    		token: {
    			// code
    			type: String,
    			require: true
    		}
    	}]

    });

    // export the User model
    module.exports = {User};


  server/server.js

  ...
    // POST to /users same for creating new todos
    app.post('/users', (req, res) => {
    	var body = _.pick(req.body, ['email', 'password']);
    	var user = new User(body);

    	user.save().then((user) => {
    		res.send(user);
    	}, (e) => {
    		res.status(400).send(e);
    	});
    });
















  //////////////////////////////////////////////////////////////////
  S: 8; P: 89; 'JWTs and Hashing'
  //////////////////////////////////////////////////////////////////

  encryption & hashing algorithms i.e. AES, MD5, SHA 256

  hashing = 1 way algorithm meaning given this 'message' you will always get the same result BUT YOU CAN NOT GET THE ORIGINAL MESSAGE BACK with just the result

  so with the hash you have no idea what the message is...

  HOW IS HASHING USED? passwords stored in the database

  hashing is a way to obfuscate a plain text password
  someone in the middle could still see the value.... https prevents the MITM attack
  BUT prevents someone on client from manipulating value and changing it to something else

  EXAMPLE: Let's say app sends token for user 3, user 3 changes token to user 4 and tries to delete someone elses data ... we can ensure value, the user id, does not change, spot change, deny user access because they probably created token on their own....


  playground/hashing.js



  // grab prop off require return result
  const {SHA256} = require('crypto-js');
  const jwt = require('jsonwebtoken');


  // https://jwt.io/

  // create token
  // verify it

  var data = {
    id: 10
  };
  var token = jwt.sign(data, '123abc');
  console.log(token);
  // jwt.sign // takes obj (data w user id), signs it, returns token value
  // jwt.verify // takes token + secret to ensure data not manipulated (shared secret)
  // var decoded = jwt.verify(token + '1', '123abc');
  // var decoded = jwt.verify(token, '123abcc');
  var decoded = jwt.verify(token, '123abc');
  console.log('decoded', decoded);





  // var message = 'I am user number 3';
  // var hash = SHA256(message).toString();
  //
  // console.log(`Message: ${message}`);
  // console.log(`Hash: ${hash}`);

  // // JWT concept
  // var data = {
  //   id: 4
  // };
  // // var token = {
  // //   data,
  // //   hash: SHA256(JSON.stringify(data)).toString()
  // // }
  // // token not foolproof... let's say user changes the data.id property to 5 all they have to do is re-hash that data > add it on to the 'hash' property > send the 'token' back and they technically could trick us... HOW TO PREVENT THIS?
  // // 'salt the hash' === add something onto the hash that's unique that changes the value
  // // password + somesecret
  //
  // var token = {
  //   data,
  //   hash: SHA256(JSON.stringify(data) + 'somesecret').toString() // somesecret is only on the server...
  // }
  //
  // // mocks up a hash manipulation
  // // token.data.id = 5;
  // // token.hash = SHA256(JSON.stringify(token.data)).toString();
  //
  // var resultHash = SHA256(JSON.stringify(token.data) + 'somesecret').toString();
  //
  // if (resultHash === token.hash) {
  //   // data not manipulated bc of the salt
  //   console.log('Data was not changed');
  // } else {
  //   // data was changed, do not trust, likely incorrect/malicious
  //   console.log(('Data was changed. Do not trust.'));
  // }
